"""
ChatKit Store Implementation using Neon PostgreSQL

Provides database-backed persistence for ChatKit threads and messages.
"""

from typing import Optional, List
from datetime import datetime
from chatkit.store import Store
from chatkit.types import (
    Thread,
    ThreadItem,
    ThreadMetadata,
    Attachment,
    Page,
    ActiveStatus,
    UserMessageItem,
    AssistantMessageItem,
    UserMessageTextContent,
    AssistantMessageContent,
    InferenceOptions,
)
from app.core.database import get_session
from app.models.conversation import Conversation
from app.models.message import Message, MessageRole
from sqlmodel import select
import logging
import uuid

logger = logging.getLogger(__name__)


class DatabaseStore(Store[str]):
    """
    Database-backed ChatKit store using our existing Conversation models.

    Context type is str (user_id) for authentication.
    """

    def generate_thread_id(self, context: str) -> str:
        """
        Generate unique thread ID for a user context.

        Returns a placeholder ID since actual conversation IDs are
        auto-generated by the database.
        """
        # Return placeholder - actual ID assigned when conversation created
        return "0"

    def generate_item_id(self, item_type: str, thread: Thread, context: str) -> str:
        """Generate unique item ID for a thread item."""
        # item_type can be "message", "action", etc.
        # We include thread ID to make it more specific
        return f"item_{thread.id}_{uuid.uuid4().hex[:12]}"

    async def load_thread(
        self,
        thread_id: str,
        context: str,
    ) -> Thread | None:
        """Load a thread by ID."""
        try:
            user_id = context
            async for session in get_session():
                # Try to find conversation by ID
                stmt = select(Conversation).where(
                    Conversation.id == int(thread_id),
                    Conversation.user_id == user_id
                )
                result = await session.execute(stmt)
                conversation = result.scalar_one_or_none()

                if not conversation:
                    return None

                # Return ThreadMetadata - SDK will convert to Thread with items
                # The SDK calls _load_full_thread which combines metadata + items
                return ThreadMetadata(
                    id=str(conversation.id),
                    title=conversation.title,  # Use actual title from database
                    created_at=conversation.created_at,  # Use datetime object
                    status=ActiveStatus(),  # Required field with default
                    metadata={},  # Custom metadata dict
                )
        except Exception as e:
            logger.error(f"Error loading thread: {e}")
            return None

    async def load_threads(
        self,
        thread_ids: Optional[List[str]] = None,
        limit: int = 20,
        context: Optional[str] = None,
        **kwargs  # Accept any other parameters ChatKit might pass
    ) -> Page[Thread]:
        """Load multiple threads by IDs or list user's threads."""
        if thread_ids:
            # Load specific threads
            threads = []
            for thread_id in thread_ids:
                thread = await self.load_thread(thread_id, context or "")
                if thread:
                    threads.append(thread)
            # Return Page with has_more based on whether we have more threads
            return Page(data=threads[:limit], has_more=len(threads) > limit)
        else:
            # List all threads for the user (with limit)
            try:
                user_id = context or ""
                async for session in get_session():
                    # Fetch one more than limit to check if there are more
                    stmt = (
                        select(Conversation)
                        .where(Conversation.user_id == user_id)
                        .order_by(Conversation.created_at.desc())
                        .limit(limit + 1)
                    )
                    result = await session.execute(stmt)
                    conversations = result.scalars().all()

                    threads = []
                    for conv in conversations[:limit]:  # Only take limit items
                        # Thread extends ThreadMetadata, so pass fields directly
                        thread = Thread(
                            id=str(conv.id),
                            title=conv.title,  # Use actual title from database
                            created_at=conv.created_at,  # Use datetime object, not string
                            status=ActiveStatus(),  # Required field with default
                            metadata={},  # Custom metadata dict
                            items=Page(data=[], has_more=False),  # Empty Page for thread list
                        )
                        threads.append(thread)

                    # has_more is True if we got more than limit
                    has_more = len(conversations) > limit
                    result = Page(data=threads, has_more=has_more)

                    # Debug: Log the response structure
                    logger.info(f"load_threads() returning {len(threads)} threads")
                    if threads:
                        logger.info(f"First thread sample: {threads[0].model_dump_json()}")

                    return result
            except Exception as e:
                logger.error(f"Error loading threads: {e}")
                return Page(data=[], has_more=False)

    async def save_thread(
        self,
        thread: Thread,
        context: str,
    ) -> None:
        """Save a thread to the database."""
        try:
            user_id = context
            async for session in get_session():
                # Check if conversation already exists
                if thread.id and thread.id.isdigit():
                    conversation_id = int(thread.id)
                    stmt = select(Conversation).where(
                        Conversation.id == conversation_id,
                        Conversation.user_id == user_id
                    )
                    result = await session.execute(stmt)
                    existing_conversation = result.scalar_one_or_none()

                    if existing_conversation:
                        # CRITICAL FIX: Detect "NEW CHAT" scenario
                        # When user clicks "New Chat", ChatKit uses thread.id="0" initially
                        # If conversation 0 already exists AND has messages, create a NEW conversation
                        if conversation_id == 0:
                            # Check if conversation has messages
                            msg_stmt = select(Message).where(
                                Message.conversation_id == conversation_id
                            ).limit(1)
                            msg_result = await session.execute(msg_stmt)
                            has_messages = msg_result.scalar_one_or_none() is not None

                            if has_messages:
                                # This is a NEW CHAT request - create a fresh conversation
                                logger.info(f"ðŸ†• NEW CHAT DETECTED: Conversation 0 has messages, creating fresh conversation")
                                new_conversation = Conversation(
                                    user_id=user_id,
                                    title=thread.title if thread.title else "New Chat"
                                )
                                session.add(new_conversation)
                                await session.commit()
                                await session.refresh(new_conversation)

                                # Update thread.id to the new conversation ID
                                # This is critical so ChatKit and our backend use the correct ID
                                thread.id = str(new_conversation.id)
                                logger.info(f"âœ¨ Created new conversation {new_conversation.id}, updated thread.id to {thread.id}")
                                break

                        # Regular update - just update title if needed
                        if thread.title and thread.title != existing_conversation.title:
                            existing_conversation.title = thread.title
                            existing_conversation.updated_at = datetime.utcnow()
                            session.add(existing_conversation)
                            await session.commit()
                            logger.info(f"Updated conversation {conversation_id} title to: {thread.title}")
                        else:
                            logger.info(f"Conversation {conversation_id} already exists, no changes needed")
                        break

                # Only create if doesn't exist
                conversation = Conversation(
                    id=int(thread.id) if thread.id.isdigit() else None,
                    user_id=user_id,
                    title=thread.title if thread.title else "New Chat"
                )
                session.add(conversation)
                await session.commit()
                logger.info(f"Created new conversation: {conversation.id} with title: {conversation.title}")
                break
        except Exception as e:
            logger.error(f"Error saving thread: {e}")

    async def delete_thread(
        self,
        thread_id: str,
        context: str,
    ) -> None:
        """Delete a thread and all its messages from the database."""
        try:
            user_id = context

            # Parse thread_id to get conversation_id
            if not thread_id or not thread_id.isdigit():
                logger.warning(f"Cannot delete thread with invalid ID: {thread_id}")
                return

            conversation_id = int(thread_id)
            logger.info(f"Deleting conversation {conversation_id} for user {user_id}")

            async for session in get_session():
                # Verify conversation exists and belongs to user
                stmt = select(Conversation).where(
                    Conversation.id == conversation_id,
                    Conversation.user_id == user_id
                )
                result = await session.execute(stmt)
                conversation = result.scalar_one_or_none()

                if not conversation:
                    logger.warning(
                        f"Conversation {conversation_id} not found or doesn't belong to user {user_id}"
                    )
                    break

                # Delete all messages first
                from sqlalchemy import delete as sql_delete
                await session.execute(
                    sql_delete(Message).where(Message.conversation_id == conversation_id)
                )

                # Delete the conversation
                await session.delete(conversation)
                await session.commit()

                logger.info(f"Successfully deleted conversation {conversation_id} for user {user_id}")
                break

        except Exception as e:
            logger.error(f"Error deleting thread {thread_id}: {e}", exc_info=True)

    async def load_thread_items(
        self,
        thread_id: str,
        after: str | None = None,
        limit: int = 50,
        order: str = "asc",
        context: str | None = None,
    ) -> Page[ThreadItem]:
        """Load all items (messages) in a thread with pagination support."""
        try:
            user_id = context

            # Extract numeric conversation ID from thread_id
            # Thread IDs can be either "123" or "thread_xxx" format
            try:
                conversation_id = int(thread_id)
            except ValueError:
                # If thread_id is not numeric, return empty page
                # This happens for new threads that haven't been created yet
                logger.warning(f"Non-numeric thread_id: {thread_id}, returning empty items")
                return Page(data=[], has_more=False, after=None)

            async for session in get_session():
                # Build query with order
                stmt = select(Message).where(
                    Message.conversation_id == conversation_id,
                    Message.user_id == user_id
                )

                # Apply ordering (asc = oldest first, desc = newest first)
                if order == "desc":
                    stmt = stmt.order_by(Message.created_at.desc())
                else:
                    stmt = stmt.order_by(Message.created_at.asc())

                # Apply pagination if after is provided
                if after:
                    # after is the message ID to start from
                    stmt = stmt.where(Message.id > int(after))

                # Fetch limit + 1 to check if there are more
                stmt = stmt.limit(limit + 1)

                result = await session.execute(stmt)
                messages = result.scalars().all()

                # Check if there are more items
                has_more = len(messages) > limit
                if has_more:
                    messages = messages[:limit]

                # Convert messages to ThreadItems
                items: List[ThreadItem] = []
                for msg in messages:
                    if msg.role == MessageRole.USER:
                        # Create user message item
                        item = UserMessageItem(
                            id=f"msg_{msg.id}",
                            thread_id=thread_id,
                            created_at=msg.created_at,
                            content=[
                                UserMessageTextContent(
                                    type="input_text",
                                    text=msg.content
                                )
                            ],
                            inference_options=InferenceOptions(),  # Required field
                        )
                        items.append(item)
                    elif msg.role == MessageRole.ASSISTANT:
                        # Create assistant message item
                        item = AssistantMessageItem(
                            id=f"msg_{msg.id}",
                            thread_id=thread_id,
                            created_at=msg.created_at,
                            content=[
                                AssistantMessageContent(
                                    type="output_text",
                                    text=msg.content,
                                    annotations=[],  # Required field
                                )
                            ],
                        )
                        items.append(item)

                # Return Page with pagination info
                return Page(
                    data=items,
                    has_more=has_more,
                    after=str(messages[-1].id) if messages and has_more else None
                )
        except Exception as e:
            logger.error(f"Error loading thread items: {e}")
            # Return empty page instead of None to avoid AttributeError
            return Page(data=[], has_more=False, after=None)

    async def load_item(
        self,
        thread_id: str,
        item_id: str,
        context: str,
    ) -> ThreadItem | None:
        """Load a single item by ID."""
        # Not implemented for simplified version
        return None

    async def save_item(
        self,
        thread_id: str,
        item: ThreadItem,
        context: str,
    ) -> None:
        """Save a thread item."""
        # Items are saved as Messages in our respond() method
        pass

    async def add_thread_item(
        self,
        thread_id: str,
        item: ThreadItem,
        context: str,
    ) -> None:
        """Add an item to a thread."""
        await self.save_item(thread_id, item, context)

    async def delete_thread_item(
        self,
        thread_id: str,
        item_id: str,
        context: str,
    ) -> None:
        """Delete a thread item (not implemented)."""
        pass

    async def load_attachment(
        self,
        thread_id: str,
        attachment_id: str,
        context: str,
    ) -> Attachment | None:
        """Load an attachment (not implemented)."""
        return None

    async def save_attachment(
        self,
        thread_id: str,
        attachment: Attachment,
        context: str,
    ) -> None:
        """Save an attachment (not implemented)."""
        pass

    async def delete_attachment(
        self,
        thread_id: str,
        attachment_id: str,
        context: str,
    ) -> None:
        """Delete an attachment (not implemented)."""
        pass
