# Implementation Plan: Phase 4 - Local Kubernetes Deployment

**Branch**: `004-phase4-k8s-deployment` | **Date**: 2025-12-25 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/004-phase4-k8s-deployment/spec.md`

**Note**: This plan was generated by the `/sp.plan` command following the spec-driven development workflow.

## Summary

Phase 4 containerizes the Phase 3 AI Chatbot application (Next.js frontend + FastAPI backend with OpenAI Agents SDK) and deploys it on local Kubernetes (Minikube) using Helm charts. The primary requirement is to maintain all 10 Phase 3 task management features through natural language while adding containerization, orchestration, horizontal scaling, and AIOps tooling. The technical approach uses Docker multi-stage builds (Node 22-alpine for frontend, Python 3.13-slim for backend), Kubernetes manifests with health checks and resource limits, Helm charts for templated deployments, and AIOps tools (Docker AI Gordon, kubectl-ai, Kagent) for intelligent operations. The stateless architecture from Phase 3 enables Kubernetes horizontal pod autoscaling and high availability with multiple replicas.

## Technical Context

**Language/Version**:
- **Backend**: Python 3.13+ with FastAPI
- **Frontend**: TypeScript (strict mode) with Next.js 16+ (App Router)
- **Infrastructure**: Docker 24+, Kubernetes 1.28+, Helm 3.x

**Primary Dependencies**:
- **Backend**: FastAPI, OpenAI Agents SDK, Official MCP SDK (Python), SQLModel, uvicorn, httpx, python-jose (JWT)
- **Frontend**: Next.js, React 18+, OpenAI ChatKit, Tailwind CSS, Better Auth
- **Container**: Docker Desktop, Docker AI (Gordon)
- **Orchestration**: Minikube, kubectl, Helm, kubectl-ai, Kagent
- **Database**: Neon Serverless PostgreSQL (external to cluster)
- **Package Managers**: UV (backend), npm/pnpm (frontend)

**Storage**:
- Neon Serverless PostgreSQL (external, accessed via Kubernetes Secret)
- Database models: Task, Conversation, Message (from Phase 3, unchanged)
- Stateless architecture: No in-memory state, all conversation data persisted to database

**Testing**:
- **Backend**: pytest, pytest-cov (unit + integration tests)
- **Container**: Docker health checks, Trivy security scanner
- **Deployment**: kubectl dry-run, Helm lint, Helm test hooks
- **Type Checking**: mypy (Python), tsc (TypeScript)
- **Linting**: ruff (Python), ESLint (TypeScript)

**Target Platform**:
- **Development**: Minikube on Docker driver (Windows WSL2 / macOS / Linux)
- **Container Runtime**: Docker Desktop 4.53+ (with Docker AI support)
- **Cluster**: Local Kubernetes (Minikube) with LoadBalancer support (minikube tunnel)
- **Phase 5 Target**: Cloud Kubernetes (DigitalOcean, GCP, Azure - out of scope)

**Project Type**: Monorepo web application with containerization and orchestration
- **frontend/**: Next.js application with ChatKit integration
- **backend/**: FastAPI application with OpenAI Agents SDK and MCP tools
- **k8s/**: Kubernetes manifests (Deployments, Services, Secrets, HPA)
- **helm/**: Helm charts for templated deployment

**Performance Goals**:
- **Container Startup**: <10 seconds for both frontend and backend containers
- **Image Build Time**: <5 minutes per image (frontend and backend)
- **Health Check Response**: <1 second for health endpoints
- **Pod Ready Time**: <60 seconds after Kubernetes deployment
- **Chat Response**: <2 seconds average (same as Phase 3)
- **Concurrent Requests**: Handle 100 concurrent chat requests (same as Phase 3)
- **Horizontal Scaling**: Scale from 2 to 10 backend pods within 2 minutes under load

**Constraints**:
- **Image Size**: Frontend <150MB, Backend <200MB (compressed)
- **Resource Limits**: Frontend (200m CPU, 256Mi RAM), Backend (500m CPU, 512Mi RAM)
- **Security**: Zero critical/high vulnerabilities in container images (Trivy scan)
- **Minikube Resources**: Minimum 4 CPU cores, 8GB RAM allocated
- **Non-Root Containers**: All containers run as UID 1000 (non-root)
- **Stateless Pods**: No persistent volumes for application state (only database)
- **External Database**: Neon PostgreSQL remains outside Kubernetes cluster

**Scale/Scope**:
- **Users**: Multi-user support with JWT authentication (same as Phase 3)
- **Replicas**: Minimum 2 replicas per service for high availability, up to 10 with HPA
- **Environments**: Dev (Minikube) in Phase 4, Prod (Cloud) in Phase 5
- **Features**: All 10 Phase 3 task management features via natural language (no regression)
- **Deployment Scope**: Local Kubernetes only (Minikube), no cloud deployment yet

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Phase 4 Principle Compliance

**✅ I. Spec-First Development**
- Specification complete at `specs/004-phase4-k8s-deployment/spec.md`
- All acceptance criteria defined for containerization, K8s deployment, Helm charts, and AIOps
- Dockerfile specs, K8s manifest specs, and Helm chart specs included in requirements
- Implementation will not begin until this plan is approved

**✅ II. Test-First (TDD - NON-NEGOTIABLE)**
- Container testing: Health check tests, startup time tests, security scan tests
- Deployment validation: Smoke tests (pods running), health check validation, scaling tests
- All tests written before implementation (Red → Green → Refactor)
- Target: >90% test coverage for backend, comprehensive deployment validation

**✅ III. YAGNI Principle (Phase 4 Scope)**
- IN SCOPE: Docker containerization, Minikube K8s deployment, Helm charts, AIOps tools
- OUT OF SCOPE: Kafka, Dapr, cloud deployment, CI/CD pipelines (Phase 5)
- All 10 Phase 3 chatbot features MUST work in containers (no regression)
- Stateless architecture validated with horizontal pod autoscaling

**✅ IV. Technology Stack Requirements**
- **Containerization**: Docker Desktop, Docker AI (Gordon), Node 22-alpine, Python 3.13-slim
- **Orchestration**: Kubernetes (Minikube 1.28+), Helm 3.x, kubectl-ai, Kagent
- **Backend**: Python 3.13, FastAPI, OpenAI Agents SDK, MCP SDK, SQLModel, UV
- **Frontend**: Next.js 16+, TypeScript, ChatKit, Tailwind CSS, Better Auth
- **Database**: Neon Serverless PostgreSQL (external to cluster)
- **Testing**: pytest, Trivy, kubectl dry-run, Helm lint

**✅ V. Clean Code & Modularity**
- Monorepo structure: `frontend/`, `backend/`, `k8s/`, `helm/`
- Dockerfiles follow multi-stage build pattern
- K8s manifests organized by component (frontend/, backend/)
- Helm charts follow standard structure with templates/ and values files
- Maximum function length: 20 lines, Maximum file length: 200 lines

**✅ VI. Type Safety**
- **Python**: mypy strict mode, full type annotations, no `Any` types
- **TypeScript**: strict mode enabled, all props typed, no implicit `any`
- **Infrastructure**: kubectl dry-run validation, Helm lint validation
- All resource requests/limits specified in K8s manifests

**✅ VII. Comprehensive Documentation**
- README.md updated with Docker setup, Minikube deployment, Helm usage
- Dockerfile documentation explaining multi-stage builds and optimization
- Kubernetes documentation for resource specs, health checks, HPA
- Helm documentation for chart structure and value customization
- AIOps tool usage documented (Gordon, kubectl-ai, Kagent)

**✅ VIII. Error Handling (Container & K8s Resilience)**
- Container health check endpoints: `GET /health` (backend), `GET /api/health` (frontend)
- Kubernetes probes: Liveness, Readiness, Startup
- Deployment error recovery: Helm --wait, automatic rollback, pod disruption budgets
- Health checks respond within 1 second, trigger restart after 3 failures

**✅ IX. Multi-User Data Isolation & Security**
- Kubernetes Secrets for sensitive data (DATABASE_URL, OPENAI_API_KEY, BETTER_AUTH_SECRET)
- Container security: Non-root user (UID 1000), read-only filesystem, dropped capabilities
- Network security: ClusterIP for backend (internal only), LoadBalancer for frontend
- JWT authentication unchanged from Phase 3, all endpoints require valid token

**✅ X. Database Schema & Migration Management**
- Neon PostgreSQL external to cluster (accessed via Kubernetes Secret)
- SQLModel automatic table creation (Phase 4), manual migrations in Phase 5
- Database models unchanged from Phase 3: Task, Conversation, Message
- Connection pooling configured for K8s (10 connections per pod)

**✅ XI. API Design & RESTful Conventions**
- All Phase 3 endpoints unchanged (containerization does not affect API design)
- NEW: Health check endpoint `GET /health` for K8s probes
- RESTful conventions maintained, JSON responses, appropriate status codes

**✅ XII. AI Agent Development & MCP Server Architecture**
- MCP server runs within FastAPI backend container (single container)
- Official MCP SDK (Python), all tools registered with schemas
- Tools are stateless (all state in database), no in-memory state
- OpenAI Agents SDK integration unchanged from Phase 3

**✅ XIII. Stateless Architecture & Conversation State Management (CRITICAL for K8s)**
- Chat endpoint is stateless (no in-memory state)
- Horizontally scalable: Any pod can handle any request
- Kubernetes-native: Pods can be killed/recreated without data loss
- Autoscaling-compatible: HPA scales pods based on CPU/memory
- Conversation state persisted to database on every request
- Multiple backend pods (replicas: 3 default) with LoadBalancer distribution

**✅ XIV. Natural Language Understanding & Intent Recognition**
- All Phase 3 NLU functionality preserved (containerization changes nothing)
- Agent understands natural language commands, maps to MCP tool calls
- Intent recognition rules unchanged from Phase 3

**✅ XV. Containerization & Docker Best Practices (NEW - Phase 4)**
- Multi-stage builds: Build stage + Production stage for frontend and backend
- Base images: node:22-alpine (frontend), python:3.13-slim (backend)
- Image optimization: .dockerignore, minimize layers, no dev dependencies
- Security: Non-root user, Trivy scan (zero critical vulnerabilities)
- Health checks: HEALTHCHECK directive in Dockerfiles (30s interval, 10s timeout, 3 retries)
- Docker AI (Gordon) for intelligent Dockerfile optimization

**✅ XVI. Kubernetes Deployment & Orchestration (NEW - Phase 4)**
- Resource management: Requests and limits defined for all pods
- Health checks: Liveness, Readiness, Startup probes
- High availability: Minimum 2 replicas per service, rolling updates
- Horizontal Pod Autoscaling: Backend (2-10 pods, CPU 70%), Frontend (2-5 pods, CPU 80%)
- Networking: ClusterIP (backend internal), LoadBalancer/NodePort (frontend external)
- Configuration: ConfigMaps (non-sensitive), Secrets (sensitive data)
- Labels: app, component, version on all resources
- kubectl-ai and Kagent for intelligent operations

**✅ XVII. Helm Chart Management (NEW - Phase 4)**
- Chart structure: Chart.yaml, values.yaml, values-dev.yaml, templates/, tests/
- Helm lint validation: Chart must pass without errors
- Templating: Parameterize replicas, image tags, resources, service types
- _helpers.tpl for common labels and selectors
- Environment-specific values: values.yaml (default), values-dev.yaml (dev overrides)
- Helm testing: test-connection.yaml validates frontend/backend connectivity
- Deployment: helm install --wait, helm upgrade, helm rollback

**✅ XVIII. AIOps & Infrastructure as Code (NEW - Phase 4)**
- Docker AI (Gordon): Dockerfile optimization, security analysis
- kubectl-ai: Natural language K8s operations, troubleshooting
- Kagent: Cluster health analysis, resource optimization
- Infrastructure as Code: All Dockerfiles, K8s manifests, Helm charts version controlled
- GitOps workflow: git commit → review → merge → deploy
- Change management: PR reviews required, ADRs for significant decisions

### Quality Gates (Pre-Implementation)

**Container Quality Gates:**
- [ ] Dockerfiles use multi-stage builds (build + production stages)
- [ ] Base images pinned to specific versions (no `latest` tags)
- [ ] .dockerignore files exclude development files and dependencies
- [ ] Health check endpoints implemented and tested
- [ ] Container images scanned with Trivy (zero critical/high vulnerabilities)
- [ ] Containers run as non-root user (UID 1000)
- [ ] Image size targets met (Frontend <150MB, Backend <200MB)

**Kubernetes Quality Gates:**
- [ ] Resource requests and limits defined for all pods
- [ ] Liveness, Readiness, and Startup probes configured
- [ ] Multiple replicas configured for high availability (minimum 2)
- [ ] HPA configured for backend autoscaling (2-10 pods)
- [ ] Secrets created for sensitive data (DATABASE_URL, OPENAI_API_KEY, BETTER_AUTH_SECRET)
- [ ] Services configured (ClusterIP for backend, LoadBalancer for frontend)
- [ ] All manifests validated with `kubectl --dry-run=client`
- [ ] Labels present on all resources (app, component, version)

**Helm Quality Gates:**
- [ ] Chart structure follows best practices (Chart.yaml, values.yaml, templates/, tests/)
- [ ] Helm lint passes without errors
- [ ] Helm install --dry-run succeeds
- [ ] Values parameterized (replicas, image tags, resources, service types)
- [ ] _helpers.tpl defines common labels and selectors
- [ ] Environment-specific values files (values.yaml, values-dev.yaml)
- [ ] Test templates validate connectivity

**Deployment Quality Gates:**
- [ ] All pods reach Ready state within 60 seconds
- [ ] Health checks pass for all pods
- [ ] Services accessible (frontend externally, backend internally)
- [ ] Conversation state persists across pod restarts
- [ ] Horizontal scaling tested (HPA scales pods up/down)
- [ ] Zero message loss during pod restarts
- [ ] All 10 Phase 3 features work correctly (100% feature parity)

**Testing Quality Gates:**
- [ ] Container health check tests written and passing
- [ ] Container startup time tests written and passing (<10 seconds)
- [ ] Security scan tests automated (Trivy in CI)
- [ ] Deployment smoke tests written (pods running, services accessible)
- [ ] Health check validation tests written (liveness/readiness probes)
- [ ] Scaling tests written (HPA behavior validated)
- [ ] End-to-end tests for all Phase 3 features in containerized environment

### Constitution Compliance: ✅ PASS

All 18 principles (I-XVIII) are satisfied by this implementation plan. No violations identified. Phase 4 adds containerization and Kubernetes deployment while maintaining all Phase 3 functionality and principles.

## Project Structure

### Documentation (this feature)

```text
specs/004-phase4-k8s-deployment/
├── spec.md              # Feature specification (/sp.specify output)
├── plan.md              # This file (/sp.plan output)
├── research.md          # Phase 0: Technology research and decisions
├── data-model.md        # Phase 1: Data entities (minimal - Phase 3 models unchanged)
├── quickstart.md        # Phase 1: Deployment quickstart guide
├── contracts/           # Phase 1: Docker and K8s specifications
│   ├── docker/
│   │   ├── frontend-dockerfile-spec.md
│   │   └── backend-dockerfile-spec.md
│   ├── kubernetes/
│   │   ├── deployment-spec.md
│   │   ├── service-spec.md
│   │   └── hpa-spec.md
│   └── helm/
│       └── chart-spec.md
├── checklists/
│   └── requirements.md  # Specification quality checklist
└── tasks.md             # Phase 2: Atomic implementation tasks (/sp.tasks output - NOT created by /sp.plan)
```

### Source Code (repository root)

**Monorepo Web Application with Containerization and Orchestration**

```text
evolved-todo/
├── frontend/                          # Next.js frontend application
│   ├── Dockerfile                     # NEW: Multi-stage build for frontend
│   ├── .dockerignore                  # NEW: Exclude dev files from image
│   ├── app/
│   │   ├── (app)/
│   │   │   └── chat/
│   │   │       └── page.tsx          # ChatKit integration (Phase 3)
│   │   ├── api/
│   │   │   └── health/               # NEW: Health check endpoint
│   │   │       └── route.ts
│   │   └── layout.tsx
│   ├── components/                    # React components
│   ├── lib/                           # API client, utilities
│   ├── types/                         # TypeScript types
│   ├── package.json
│   ├── next.config.js
│   ├── tsconfig.json
│   └── __tests__/                     # Frontend tests
│
├── backend/                           # FastAPI backend application
│   ├── Dockerfile                     # NEW: Multi-stage build for backend
│   ├── .dockerignore                  # NEW: Exclude dev files from image
│   ├── app/
│   │   ├── main.py                    # FastAPI entry point
│   │   ├── health.py                  # NEW: Health check endpoint
│   │   ├── models.py                  # SQLModel models (Task, Conversation, Message)
│   │   ├── db.py                      # Database connection
│   │   ├── auth.py                    # JWT authentication
│   │   ├── routes/
│   │   │   ├── chat.py                # Chat endpoint (Phase 3)
│   │   │   └── tasks.py               # Task endpoints (Phase 3)
│   │   ├── services/                  # Business logic (Phase 3)
│   │   ├── mcp/                       # MCP server and tools (Phase 3)
│   │   │   ├── server.py
│   │   │   └── tools/
│   │   │       ├── add_task.py
│   │   │       ├── list_tasks.py
│   │   │       ├── complete_task.py
│   │   │       ├── delete_task.py
│   │   │       └── update_task.py
│   │   └── agents/                    # OpenAI Agents SDK config (Phase 3)
│   │       └── todo_agent.py
│   ├── tests/
│   │   ├── unit/                      # Unit tests (Phase 3)
│   │   ├── integration/               # Integration tests (Phase 3)
│   │   └── container/                 # NEW: Container tests
│   │       ├── test_health_check.py
│   │       ├── test_startup_time.py
│   │       └── test_security_scan.py
│   ├── pyproject.toml                 # UV package management
│   └── uv.lock
│
├── k8s/                               # NEW: Kubernetes manifests
│   ├── namespace.yaml
│   ├── secrets.yaml.template          # Template (actual secrets not committed)
│   ├── configmaps.yaml
│   ├── frontend/
│   │   ├── deployment.yaml            # Frontend Deployment
│   │   ├── service.yaml               # Frontend Service (LoadBalancer/NodePort)
│   │   └── hpa.yaml                   # Frontend HPA (2-5 replicas)
│   └── backend/
│       ├── deployment.yaml            # Backend Deployment
│       ├── service.yaml               # Backend Service (ClusterIP)
│       └── hpa.yaml                   # Backend HPA (2-10 replicas)
│
├── helm/                              # NEW: Helm charts
│   └── evolved-todo/
│       ├── Chart.yaml                 # Chart metadata
│       ├── values.yaml                # Default values (production)
│       ├── values-dev.yaml            # Development overrides
│       ├── templates/
│       │   ├── _helpers.tpl           # Template helpers (labels, selectors)
│       │   ├── namespace.yaml
│       │   ├── secrets.yaml
│       │   ├── configmaps.yaml
│       │   ├── frontend/
│       │   │   ├── deployment.yaml
│       │   │   ├── service.yaml
│       │   │   └── hpa.yaml
│       │   └── backend/
│       │       ├── deployment.yaml
│       │       ├── service.yaml
│       │       └── hpa.yaml
│       └── tests/
│           └── test-connection.yaml   # Helm test for connectivity
│
├── docs/                              # NEW: Deployment documentation
│   ├── docker/
│   │   ├── frontend-dockerfile.md     # Frontend Dockerfile explanation
│   │   ├── backend-dockerfile.md      # Backend Dockerfile explanation
│   │   └── aiops-gordon.md            # Docker AI (Gordon) usage guide
│   ├── kubernetes/
│   │   ├── minikube-setup.md          # Minikube installation and config
│   │   ├── deployment-guide.md        # K8s deployment walkthrough
│   │   ├── scaling-guide.md           # HPA configuration and testing
│   │   └── troubleshooting.md         # Common K8s issues and solutions
│   ├── helm/
│   │   ├── chart-structure.md         # Helm chart organization
│   │   ├── values-customization.md    # How to customize values
│   │   └── upgrade-rollback.md        # Helm upgrade and rollback procedures
│   └── aiops/
│       ├── kubectl-ai-guide.md        # kubectl-ai usage examples
│       └── kagent-guide.md            # Kagent usage examples
│
├── specs/                             # Feature specifications (existing)
│   ├── 001-phase1-todo-app/          # Phase 1 specs
│   ├── 002-phase2-web-app/           # Phase 2 specs
│   ├── 003-phase3-ai-chatbot/        # Phase 3 specs
│   └── 004-phase4-k8s-deployment/    # THIS FEATURE
│
├── history/                           # Historical records (existing)
│   ├── prompts/                       # Prompt History Records
│   └── adr/                           # Architecture Decision Records
│
├── .specify/                          # Spec-Kit Plus configuration (existing)
│   ├── memory/
│   │   └── constitution.md            # Project constitution (v4.0.0)
│   ├── templates/                     # SDD templates
│   └── scripts/                       # Automation scripts
│
├── .gitignore
├── docker-compose.yml                 # NEW: Local dev environment (optional)
├── AGENTS.md                          # Agent behavior guidelines
├── CLAUDE.md                          # Claude Code configuration
└── README.md                          # Updated with Docker and K8s instructions
```

**Structure Decision**: Phase 4 extends the existing monorepo with containerization and orchestration directories. The `frontend/` and `backend/` directories from Phase 3 remain unchanged except for adding Dockerfiles, .dockerignore files, and health check endpoints. New directories added:
- **k8s/**: Raw Kubernetes manifests for manual deployment and learning
- **helm/**: Helm charts for production-like templated deployments
- **docs/**: Comprehensive documentation for Docker, Kubernetes, Helm, and AIOps tools

The structure maintains clean separation between application code (frontend/, backend/), infrastructure definitions (k8s/, helm/), and documentation (docs/). All Phase 3 code remains in place with zero changes to business logic, ensuring backward compatibility and feature preservation.

## Complexity Tracking

**No violations identified.** All Constitution Check gates pass. No complexity justifications required for Phase 4.
